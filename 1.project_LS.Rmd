---
title: 'Project 1: Areal data analysis'
author: "Laura Sudupe. email: laura.medinilla@kaust.eu.sa"
date: "10/1/2022"
geometry: margin=2cm
fontsize: 12pt
output: html_document
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r libraries, include =FALSE}
library(sf)
library(epitools)
library(SpatialEpi)
library(spData)
library(ggplot2)
library(leaflet)
library(spdep)
library(INLA)
library(tidyverse)
library(palmerpenguins)
library(ggdist)
library(gridExtra)
library(PerformanceAnalytics)
```


# New Zeland aeral data analysis


### Abstract

**This project will be focused on analyzing New Zeland (NZ) aeral data using Rstudio. The project is the first one of the three we need to prepare for the <a href = "https://www.paulamoraga.com/book-gds/index.html">STAT394 course</a>. In the first section we are going to describe NZ data and briefly explain areal data type. Next, we will focus on preparing the data for the statistical modelling. After this, we are going to go through the results, understanding the meaning and finally a short discussion of the project.**

```{r echo=F, warning= F, message=F}
#opts_chunk$set(message = FALSE, warning = FALSE, error = FALSE, tidy = FALSE, cache = FALSE,results = 'asis' )
```


### Introduction

**When we are working with a fixed domain which is divided in a finite number or sub regions where we have aggregated data, we can say we are working with Aeral data. This type pf data is presented as attributes of fixed polygonal areas, this areas doesn't need to be regular shaped. We can apply statistical methods to extract attributes and analyze then in space.**


**As part of the STAT394 course, in this project we are going to focus on nz (spData), where we have regions in New Zealand and as part of the course, we are going to model the data using INLA.**


### Data

**Brief description of the dataset, we can see it is a sf object**

```{r data, include=FALSE}
data("nz")
head(nz)
str(nz)
?nz

#https://www.ehinz.ac.nz/indicators/uv-exposure/melanoma/
cases <- read.csv("./new-cancer-registrations-2017-data-files-dec19/cancer.csv", sep = ",")
nz$cases <- cases$cases
```

```{r statistical_description, echo = F}
class(nz)
names(nz)
```

**The dataset is "sf" class and it contains 16 observations and 7 variables. The followings:**

***- Name: The county name***

***- Island: North or Shout location of the county***

***- Land_area: The area of each county***

***- Population: The total population of each county***

***- Median_income: Median income of the county***

***- Sex_ratio: Ratio in each of the counties***

***- Geom: The variable with the spatial information***


**In our case, we are going to focus on the median income and try to see the dependence of it with the population in each county. In the next plots we can observe how are our variables distributed. For the population, we can see almost all the points are bellow 500 000. We have a pick in the South with more counties with low population, the north counties are more homogeneous. If we focus on the Median_income, the South shows most of the point between 25 000 and 30 000. In the north, the range of values is larger. Even though, the south counties show us more homogeneous distribution of the Land_area than the North.**

```{r statistical_description_1, echo=F}
a <- nz %>%
  ggplot(aes(x=Population, y=Island, fill=Island))+
  stat_slab(aes(thickness = stat(pdf*n)), 
                scale = 0.3) +
  stat_dotsinterval(side = "bottom", 
                    scale = 0.3, 
                    slab_size = NA) 
b <- nz %>%
  ggplot(aes(x=Median_income, y=Island, fill=Island))+
  stat_slab(aes(thickness = stat(pdf*n)), 
                scale = 0.3) +
  stat_dotsinterval(side = "bottom", 
                    scale = 0.3, 
                    slab_size = NA)
c <- nz %>%
  ggplot(aes(x=cases, y=Island, fill=Island))+
  stat_slab(aes(thickness = stat(pdf*n)), 
                scale = 0.3) +
  stat_dotsinterval(side = "bottom", 
                    scale = 0.3, 
                    slab_size = NA) 

d <- nz %>%
  ggplot(aes(x=Sex_ratio, y=Island, fill=Island))+
  stat_slab(aes(thickness = stat(pdf*n)), 
                scale = 0.3) +
  stat_dotsinterval(side = "bottom", 
                    scale = 0.3, 
                    slab_size = NA) 

grid.arrange(a, b, c, d,  ncol=2)
```


**In this data we have the sex_ratio. This variable give us the ratio of female to males in a population, it tends to be 1:1. In our case, we are going to transform the data**

**-Sex_ratio = 1, then "same"**

**-Sex_ratio > 1, then "female"**

**-Sex_ratio < 1, then "male"**


```{r statistical_description_3, echo=F, message=FALSE, warning=FALSE}
nz$Island <- as.factor(nz$Island)
##https://rdrr.io/cran/SpatialEpi/src/R/expected.R
nz$sex <- ifelse(nz$Sex_ratio == 1, 'same', ifelse(nz$Sex_ratio > 1, 'female', "male"))
nz$Population <- as.integer(nz$Population)

###expected cases
##area: name of the area
##Y: observed number of cases, in my case, median income
##E: expected number of cases in my case, expected median income
##I want it to depend on
##population in each 
##SMIR in each area

```


**In the next plot we check the correlation between the principal variables. There is a correlation between the Land_area and the Sex_ratio. When Land_area values is decreasing, the Sex_ratio is also decreasing, positive correlation. Overall, we are not seeing a bit correlation values between variables. In this work we are going to focus on the Median_income as a response variable, we can see a 0.44 correlation score between the Median_income and Population variables.**


```{r statistical_description_2, echo=F, message=FALSE, warning=FALSE}
nz$Population <- as.numeric(nz$Population)
nz$Median_income <- as.numeric(nz$Median_income)
nz$Sex_ratio <- as.numeric(nz$Sex_ratio)
nz$Land_area <- as.numeric(nz$Land_area)
nz$cases <- as.numeric(nz$cases)
b<- nz[,3:6] 
b$cases <- nz$cases
b$geom <- NULL
chart.Correlation(b, histogram = TRUE, method = "pearson")
```



**Along with the observed values, we want to know the expected ones. For this, we use the expected() function of the SpatialEpi package. For this analysis, we want to calculate the expected median_income. We divided the data between sex and hemisphere**

```{r statistical_description_4, echo=T}
#Expected 
nz$e <- expected(population = nz$Population, cases = nz$cases, n.strata = 4)
```

```{r statistical_description_5, echo=F}
nz$SMR <- nz$cases / nz$e
```


**Let's see our final variables in a spatial plot. We can see that only in one of the counties the ratio between female and males is higher for females**


```{r summary, message=FALSE, echo=F}
if (requireNamespace("sf", quietly = TRUE)) {
  library(sf)
  summary(nz)
  plot(nz)
}
```


**In our case, the map does not have the Coordinate Reference System (CRS) data. For this reason, we need to add it by ourself. Also, we need to convert the data to SpatialPolygonsDataFrame**


```{r spatial, message=FALSE, echo=T}
#convert to SpatialPolygonsDataFrame
map_spdf <- as_Spatial(nz, IDs = TRUE) 
wgs84 = '+proj=longlat +datum=WGS84'
nz_region <- spTransform(map_spdf, CRS(wgs84))

class(map_spdf)
```


### Visual plots of the data

**Let's focus on the Median_income, We can see Welington county in the North is the one with the highest income. In general the south has more heterogeneous income**


```{r SMR, message=FALSE, echo=F}
###Mapping SMR
le <- leaflet(nz_region) %>% addTiles()
pale <- colorNumeric(palette = "YlOrRd", domain = nz_region$SMR)

le %>% addPolygons(color = "grey", weight = 1, fillColor = ~pale(SMR), fillOpacity = 0.5) %>%
  leaflet::addLegend(pal = pale, values = ~SMR, opacity = 0.5, title = "SMR", position = "bottomright")
```



```{r Median_income, message=FALSE, echo=F}
###Mapping median income
le <- leaflet(nz_region) %>% addTiles()
pale <- colorNumeric(palette = "YlOrRd", domain = nz_region$Median_income)

le %>% addPolygons(color = "grey", weight = 1, fillColor = ~pale(Median_income), fillOpacity = 0.5) %>%
  leaflet::addLegend(pal = pale, values = ~Median_income, opacity = 0.5, title = "Median_income", position = "bottomright")
```

**Related to the Population, Auckland has the highest population values. In general, we can see a heterogeneus landscape in the map.**


```{r Population, message=FALSE, echo=F}
###Mapping Population
le <- leaflet(nz_region) %>% addTiles()
pale <- colorNumeric(palette = "YlOrRd", domain = nz_region$Population)

le %>% addPolygons(color = "grey", weight = 1, fillColor = ~pale(Population), fillOpacity = 0.5) %>%
  leaflet::addLegend(pal = pale, values = ~Population, opacity = 0.5, title = "Population", position = "bottomright")
```

### Analyses

***For this proyect, we are going to use <a href = "https://www.r-inla.org/">INLA package</a> to model the data. This package is used to do approximate Bayesian inference for Latent Gaussian Models***

***In our case, Yi is going to be the observed Median_income and Ei the expected one.  ***

Let Yi and Ei be the observed and expected number of disesase cases, respectively, and let θi be the relative risk for county i=1,…,n. The model is specified as follows:

Yi|θi∼Poisson(Ei×θi), i=1,…,n,

log(θi)=β0+β1×smokingi+ui+vi.

β0 is the intercept,
β1 is the coefficient of the smokers proportion covariate,
ui is a structured spatial effect, ui|u−i∼N(u¯δi,1τunδi) (Conditionally autoregressive model (CAR)),
vi is an unstructured spatial effect, vi∼N(0,1/τv).


***We need to define some parameters before running the model. First, we need to created a neighborhood matrix where we define the spatial random effect. With poly2nb() function we create a neighbors list based on the areas surrounding the boundaries. For each area, we have the indices of its neighbors. After this, with nb2INLA() we transform the list in a file representing the matrix. R-INLA package need this file to work with to be able to specify the spatial random effect.***


```{r modelling_1, message=FALSE, echo=F, include=FALSE}
nb_nz <- poly2nb(nz_region)
head(nb_nz)
nb_nz[[1]] #the first county has 2 neighbours

nb2INLA("nz_region.adj", nb_nz)
ge <- inla.read.graph(filename = "nz_region.adj")
```



***For the model, we need to create two variables, where we are going to have the random effect values. Ui to model the spatial residual variation, and vi to model unstructured noise.***



```{r modelling_2, message=FALSE, echo=F, include=FALSE}
###inference using inla
#create variables
nz_region$re_u <- 1:nrow(nz_region@data)
nz_region$re_v <- 1:nrow(nz_region@data)
```


***Define the formula***

```{r modelling_3, message=FALSE, echo=T}
formula <- cases ~ Sex_ratio + 
  f(re_u, model = "besag", graph = ge, scale.model = TRUE) + 
  f(re_v, model = "iid")
```



***Let's fit the model***

```{r modelling_4, message=FALSE, echo=T}
#https://groups.google.com/g/r-inla-discussion-group/c/EPTiPRE7jAM?pli=1 ERROR
rese <- inla(formula, family = "poisson", data = nz_region@data,
             E = e,
             control.predictor = list(compute = TRUE),
             control.compute=list(return.marginals.predictor=TRUE))

```



### Results and Interpretation

We can focus on the intercept X C=-1.152 value with 95% credible interval between -1.674 and -0.629. The coeficient for Population is 0.000

***We can focus on the intercept β̂ 0=-1.15 2va

***We can focus on the intercept β̂ 0=-1.152value wit 95% credible interval (d32ff2, -0.028
We see the intercept β̂ 0= -0.323 with a 95% credible interval equal to (-0.621, -0.028), and the coefficient of smoking is β̂ 1= 1.156 with a 95% credible interval equal to (-0.081, 2.384). We can plot the posterior distribution of the smoking coefficient. We do this by calculating a smoothing of the marginal distribution of the coefficient with inla.smarginal() and then plot it with ggplot() of the ggplot2 package.***



```{r results, message=FALSE, echo=F}
summary(rese)
```

ddddgtgtff  


***Extraction of the posterior information***


```{r}
library(faraway)
library(gridExtra)
#http://julianfaraway.github.io/brinla/examples/chicago.html
#https://github.com/julianfaraway/brinla
#remotes::install_github("julianfaraway/brinla")
library(brinla)
bri.hyperpar.summary(rese)
bri.hyperpar.plot(rese)
bri.fixed.plot(rese)
```



```{r results_2, message=FALSE, echo=F}
#names(inla.models()$likelihood)
###results
#summary(rese)
rese$summary.fitted.values

marginale <- inla.smarginal(rese$marginals.fixed$Sex_ratio)
marginale <- data.frame(marginale)
ggplot(marginale, aes(x = x, y = y)) + geom_line() + labs(x = expression(beta[1]), y = "Density") +
  geom_vline(xintercept = 0, col = "blue") + theme_bw()
```



```{r results_3, message=FALSE, echo=F}
###add results to map
head(rese$summary.fitted.values)

nz_region$RR <- rese$summary.fitted.values[, "mean"]
nz_region$LL <- rese$summary.fitted.values[, "0.025quant"]
nz_region$UL <- rese$summary.fitted.values[, "0.975quant"]

###mappring median income
pale <- colorNumeric(palette = "YlOrRd", domain = nz_region$RR)

labels <- sprintf("<strong> %s </strong> <br/> Observed: %s <br/> Expected: %s <br/>
                  Smokers proportion: %s <br/>SMR: %s <br/>RR: %s (%s, %s)",
                  nz_region$Name, nz_region$Median_income,  round(nz_region$e, 2),  
                  nz_region$Sex_ratio, round(nz_region$SMR, 2),
                  round(nz_region$RR, 2), round(nz_region$LL, 2), round(nz_region$UL, 2)) %>%
  lapply(htmltools::HTML)

leaflet(nz_region) %>% addTiles() %>%
  addPolygons(color = "grey", weight = 1, fillColor = ~pale(RR),  fillOpacity = 0.5,
              highlightOptions = highlightOptions(weight = 4),
              label = labels,
              labelOptions = labelOptions(style = list("font-weight" = "normal", padding = "3px 8px"),
                                          textsize = "15px", direction = "auto")) %>%
  leaflet::addLegend(pal = pale, values = ~RR, opacity = 0.5, title = "RR", position = "bottomright")
```

### Discussion section


What can I do better

  - More variables to check
  - Low number of data points to proper work
  
  
**With this project I learned how to download, manipulate and analize areal data. I work with different packages to do so,  **
What I learned

  - Manipulate spatial data
  - Show results in spatial data
  - Use INLA package
  - Deliver results
  
General comment

  - 
  
### Doubts

- do i need ecpected values
- is normal to get intercept 0
- what do i get with the mean if it is not the risk

  
  

