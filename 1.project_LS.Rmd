---
title: 'Project 1: Areal data analysis'
author: "Laura Sudupe. email: laura.medinilla@kaust.eu.sa"
date: "10/1/2022"
geometry: margin=2cm
fontsize: 12pt
output: html_document
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r libraries, include =FALSE}
library(sf)
library(epitools)
library(SpatialEpi)
library(spData)
library(ggplot2)
library(leaflet)
library(spdep)
library(INLA)
library(tidyverse)
library(palmerpenguins)
library(ggdist)
library(gridExtra)
library(PerformanceAnalytics)
```


# New Zeland aeral data analysis


### Abstract

**This project will be focused on analyzing New Zeland (NZ) aeral data using Rstudio. The project is the first one of the three we need to prepare for the <a href = "https://www.paulamoraga.com/book-gds/index.html">STAT394 course</a>. In the first section we are going to describe NZ data and briefly explain areal data type. Next, we will focus on preparing the data for the statistical modelling. After this, we are going to go through the results, understanding the meaning and finally a short discussion of the project.**

```{r echo=F, warning= F, message=F}
#opts_chunk$set(message = FALSE, warning = FALSE, error = FALSE, tidy = FALSE, cache = FALSE,results = 'asis' )
```


### Introduction

Aeral data

NZ data

STAT394 course, INLA modelling

### Data

Statistical description of the data

```{r data, include=FALSE}
data("nz")
head(nz)
str(nz)
?nz
```

```{r statistical_description, echo = F}
class(nz)
names(nz)
```

**The dataset is "sf" class and it contains 16 observations and 7 variables. The followings:**

**- Name: The county name**

**- Island: North or Shout location of the county**

**- Land_area: The area of each county**

**- Population: The total population of each county**

**- Median_income: Median income of the county**

**- Sex_ratio: Ratio in each of the counties**

**- Geom: The variable with the spatial information**


**In our case, we are going to focus on the median income and try to see the dependence of it with the population in each county. In the next plots we can observe how are our variables distributed. For the population, we can see almost all the points are bellow 500 000. We have a pick in the South with more counties with low population, the north counties are more homogeneous. If we focus on the Median_income, the South shows most of the point between 25 000 and 30 000. In the north, the range of values is larger. Even though, the south counties show us more homogeneus distribution of the Land_area than the North.**

```{r statistical_description_1, echo=F}
a <- nz %>%
  ggplot(aes(x=Population, y=Island, fill=Island))+
  stat_slab(aes(thickness = stat(pdf*n)), 
                scale = 0.3) +
  stat_dotsinterval(side = "bottom", 
                    scale = 0.3, 
                    slab_size = NA) 
b <- nz %>%
  ggplot(aes(x=Median_income, y=Island, fill=Island))+
  stat_slab(aes(thickness = stat(pdf*n)), 
                scale = 0.3) +
  stat_dotsinterval(side = "bottom", 
                    scale = 0.3, 
                    slab_size = NA)
c <- nz %>%
  ggplot(aes(x=Land_area, y=Island, fill=Island))+
  stat_slab(aes(thickness = stat(pdf*n)), 
                scale = 0.3) +
  stat_dotsinterval(side = "bottom", 
                    scale = 0.3, 
                    slab_size = NA) 

grid.arrange(a, b, c, ncol=2)
```


**In this data we have the sex_ratio. This variable give us the ratio of female to males in a population, it tends to be 1:1. In our case, we are going to transform the data**

**-Sex_ratio = 1, then "same"**

**-Sex_ratio > 1, then "female"**

**-Sex_ratio < 1, then "male"**


```{r statistical_description_3, echo=F, message=FALSE, warning=FALSE}
nz$Island <- as.factor(nz$Island)
##https://rdrr.io/cran/SpatialEpi/src/R/expected.R
nz$sex <- ifelse(nz$Sex_ratio == 1, 'same', ifelse(nz$Sex_ratio > 1, 'female', "male"))
nz$Population <- as.integer(nz$Population)

###expected cases
##area: name of the area
##Y: observed number of cases, in my case, median income
##E: expected number of cases in my case, expected median income
##I want it to depend on
##population in each 
##SMIR in each area
#nz$RMISR <- sum(nz$Median_income[nz$sex == "male"]) / sum(nz$Median_income[nz$sex == "female"])

```

**In the next plot we check the correlation between the principal variables. There is a correlation between the Land_area and the Sex_ratio. When Land_area values is decreasing, the Sex_ratio is also decreasing, positive correlation. Overall, we are not seeing a bit correlation values between variables. In this work we are going to focus on the Median_income as a response variable, we can see a 0.44 correlation score between the Median_income and Population variables.**

```{r statistical_description_2, echo=F, message=FALSE, warning=FALSE}
nz$Population <- as.numeric(nz$Population)
nz$Median_income <- as.numeric(nz$Median_income)
nz$Sex_ratio <- as.numeric(nz$Sex_ratio)
nz$Land_area <- as.numeric(nz$Land_area)
b<- nz[,3:6]
b$geom <- NULL

chart.Correlation(b, histogram = TRUE, method = "pearson")
```



**Along with the observed values, we want to know the expected ones. For this, we use the expected() function of the SpatialEpi package. For this analysis, we want to calculate the expected median_income. We divided the data between sex and hemisphere**

```{r statistical_description_4, echo=T}
#Expected 
nz$e <- expected(population = nz$Population, cases = nz$Median_income, n.strata = 4)
```

```{r statistical_description_5, echo=F}
nz$SMIR <- nz$Median_income / nz$e
```


**Let's see our final variables in a spatial plot. We can see that only in one of the counties the ratio between female and males is higher for females**


```{r summary, message=FALSE, echo=F}
if (requireNamespace("sf", quietly = TRUE)) {
  library(sf)
  summary(nz)
  plot(nz)
}
```


**In our case, the map does not have the Coordinate Reference System (CRS) data. For this reason, we need to add it by ourself. Also, we need to convert the data to SpatialPolygonsDataFrame**

```{r spatial, message=FALSE, echo=T}
#convert to SpatialPolygonsDataFrame
map_spdf <- as_Spatial(nz, IDs = TRUE) 
wgs84 = '+proj=longlat +datum=WGS84'
nz_region <- spTransform(map_spdf, CRS(wgs84))

class(map_spdf)
```


### Visual plots of the data

**Let's focus on the Median_income, We can see Welington county in the North is the one with the highest income. In general the south has more heterogeneous income**

```{r SMIR, message=FALSE, echo=F}
###Mapping SMIR
#le <- leaflet(nz_region) %>% addTiles()
#pale <- colorNumeric(palette = "YlOrRd", domain = nz_region$SMIR)

#le %>% addPolygons(color = "grey", weight = 1, fillColor = ~pale(SMIR), fillOpacity = 0.5) %>%
  #leaflet::addLegend(pal = pale, values = ~SMIR, opacity = 0.5, title = "SMIR", position = "bottomright")
```

```{r Median_income, message=FALSE, echo=F}
###Mapping median income
le <- leaflet(nz_region) %>% addTiles()
pale <- colorNumeric(palette = "YlOrRd", domain = nz_region$Median_income)

le %>% addPolygons(color = "grey", weight = 1, fillColor = ~pale(Median_income), fillOpacity = 0.5) %>%
  leaflet::addLegend(pal = pale, values = ~Median_income, opacity = 0.5, title = "Median_income", position = "bottomright")
```

**Related to the Population, Auckland has the highest population values. In general, we can see a heterogeneus landscape in the map.**

```{r Population, message=FALSE, echo=F}
###Mapping Population
le <- leaflet(nz_region) %>% addTiles()
pale <- colorNumeric(palette = "YlOrRd", domain = nz_region$Population)

le %>% addPolygons(color = "grey", weight = 1, fillColor = ~pale(Population), fillOpacity = 0.5) %>%
  leaflet::addLegend(pal = pale, values = ~Population, opacity = 0.5, title = "Population", position = "bottomright")
```

### Analyses

***For this proyect, we are going to use <a href = "https://www.r-inla.org/">INLA package</a> to model the data. This package is used to do approximate Bayesian inference for Latent Gaussian Models***

***In our case, Yi is going to be the observed Median_income and Ei the expected one.  ***

Let Yi and Ei be the observed and expected number of disesase cases, respectively, and let θi be the relative risk for county i=1,…,n. The model is specified as follows:

Yi|θi∼Poisson(Ei×θi), i=1,…,n,

log(θi)=β0+β1×smokingi+ui+vi.

β0 is the intercept,
β1 is the coefficient of the smokers proportion covariate,
ui is a structured spatial effect, ui|u−i∼N(u¯δi,1τunδi) (Conditionally autoregressive model (CAR)),
vi is an unstructured spatial effect, vi∼N(0,1/τv).


```{r modelling_1, message=FALSE, echo=F, include=FALSE}
nb_nz <- poly2nb(nz_region)
head(nb_nz)
nb_nz[[1]] #the first county has 2 neighbours

nb2INLA("nz_region.adj", nb_nz)
ge <- inla.read.graph(filename = "nz_region.adj")

###inference using inla
#create variables
nz_region$re_u <- 1:nrow(nz_region@data)
nz_region$re_v <- 1:nrow(nz_region@data)
```

***Define the formula***

```{r modelling_2, message=FALSE, echo=T}
formula <- Median_income ~ Population + f(re_u, model = "besag", graph = ge, scale.model = TRUE) + f(re_v, model = "iid")

```


***Let's fit the model***

```{r modelling_3, message=FALSE, echo=T}

#https://groups.google.com/g/r-inla-discussion-group/c/EPTiPRE7jAM?pli=1 ERROR
rese <- inla(formula, family = "poisson", data = nz_region@data , E = e,
             control.predictor = list(compute = TRUE),
             control.compute=list(return.marginals.predictor=TRUE))


```



### Results and Interpretation

***Extraction of the posterior information***

```{r}
library(faraway)
library(gridExtra)
#http://julianfaraway.github.io/brinla/examples/chicago.html
#https://github.com/julianfaraway/brinla
#remotes::install_github("julianfaraway/brinla")
library(brinla)
bri.hyperpar.summary(rese)
bri.hyperpar.plot(rese)
bri.fixed.plot(rese)
```


```{r results, message=FALSE, echo=F}
#names(inla.models()$likelihood)
###results
#summary(rese)
rese$summary.fitted.values

marginale <- inla.smarginal(rese$marginals.fixed$Population)
marginale <- data.frame(marginale)
ggplot(marginale, aes(x = x, y = y)) + geom_line() + labs(x = expression(beta[1]), y = "Density") +
  geom_vline(xintercept = 0, col = "blue") + theme_bw()
```


```{r results_2, message=FALSE, echo=F}
###add results to map
head(rese$summary.fitted.values)

nz_region$RR <- rese$summary.fitted.values[, "mean"]
nz_region$LL <- rese$summary.fitted.values[, "0.025quant"]
nz_region$UL <- rese$summary.fitted.values[, "0.975quant"]

###mappring median income
pale <- colorNumeric(palette = "YlOrRd", domain = nz_region$RR)

labels <- sprintf("<strong> %s </strong> <br/> Observed: %s <br/> Expected: %s <br/>
                  Smokers proportion: %s <br/>SMR: %s <br/>RR: %s (%s, %s)",
                  nz_region$Name, nz_region$Median_income,  round(nz_region$e, 2),  
                  nz_region$Sex_ratio, round(nz_region$SMIR, 2),
                  round(nz_region$RR, 2), round(nz_region$LL, 2), round(nz_region$UL, 2)) %>%
  lapply(htmltools::HTML)

leaflet(nz_region) %>% addTiles() %>%
  addPolygons(color = "grey", weight = 1, fillColor = ~pale(RR),  fillOpacity = 0.5,
              highlightOptions = highlightOptions(weight = 4),
              label = labels,
              labelOptions = labelOptions(style = list("font-weight" = "normal", padding = "3px 8px"),
                                          textsize = "15px", direction = "auto")) %>%
  leaflet::addLegend(pal = pale, values = ~RR, opacity = 0.5, title = "RR", position = "bottomright")
```

### Discussion section

What can I do better

  - More variables to check
  - Low number of data points to proper work
  
What I learned

  - Manipulate spatial data
  - Show results in spatial data
  - Use INLA package
  - Deliver results
  
General comment

  - 

